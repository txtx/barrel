//! Google Antigravity agent driver.
//!
//! Antigravity uses a "rules" system for project-level instructions. This driver
//! merges all agent files into `.antigravity/rules.md` which Antigravity loads
//! automatically as always-on project rules.
//!
//! This approach is similar to the Codex driver - agents are concatenated into
//! a single file rather than symlinked individually.
//!
//! # Antigravity Configuration Hierarchy
//!
//! - Global rules: `~/.gemini/GEMINI.md`
//! - Project rules: `.antigravity/rules.md` (where axel installs agents)
//! - Workflows: `.agent/workflows/*.md` (on-demand, not used by axel)

use std::path::{Path, PathBuf};

use anyhow::Result;

use super::AgentDriver;

/// Path to the merged rules file for Antigravity
const ANTIGRAVITY_RULES_FILE: &str = ".antigravity/rules.md";

/// Antigravity agent driver
pub struct AntigravityDriver;

impl AgentDriver for AntigravityDriver {
    fn name(&self) -> &'static str {
        "antigravity"
    }

    fn agents_dir(&self, workspace_dir: &Path) -> PathBuf {
        workspace_dir.join(".antigravity")
    }

    fn agent_patterns(&self) -> &'static [&'static str] {
        &[".antigravity/rules.md", ".agent/workflows/*.md"]
    }

    fn install_agents(&self, workspace_dir: &Path, agent_paths: &[PathBuf]) -> Result<usize> {
        if agent_paths.is_empty() {
            return Ok(0);
        }

        let antigravity_dir = self.agents_dir(workspace_dir);
        std::fs::create_dir_all(&antigravity_dir)?;

        // Merge all agent files into a single rules file
        let rules_path = workspace_dir.join(ANTIGRAVITY_RULES_FILE);
        let mut merged_content = String::new();

        merged_content.push_str("# Axel Agents\n\n");
        merged_content.push_str("<!-- Auto-generated by axel. Do not edit. -->\n\n");

        let mut count = 0;
        for source_path in agent_paths {
            let name = derive_agent_name(source_path);
            let content = std::fs::read_to_string(source_path)?;

            // Strip YAML frontmatter if present
            let content = strip_frontmatter(&content);

            merged_content.push_str(&format!("## {}\n\n", name));
            merged_content.push_str(content.trim());
            merged_content.push_str("\n\n---\n\n");
            count += 1;
        }

        std::fs::write(&rules_path, merged_content)?;

        Ok(count)
    }

    fn cleanup(&self, workspace_dir: &Path) -> bool {
        let rules_file = workspace_dir.join(ANTIGRAVITY_RULES_FILE);
        // Only remove if it's a axel-generated file
        if let Ok(content) = std::fs::read_to_string(&rules_file)
            && content.contains("<!-- Auto-generated by axel.")
        {
            return std::fs::remove_file(&rules_file).is_ok();
        }
        false
    }
}

/// Derive agent name from file path.
///
/// Handles two naming conventions:
/// - `<name>/AGENT.md` → uses the directory name
/// - `<name>.md` → uses the file stem
fn derive_agent_name(path: &Path) -> String {
    if path.file_name().map(|n| n == "AGENT.md").unwrap_or(false) {
        path.parent()
            .and_then(|p| p.file_name())
            .map(|n| n.to_string_lossy().to_string())
            .unwrap_or_else(|| "agent".to_string())
    } else {
        path.file_stem()
            .map(|n| n.to_string_lossy().to_string())
            .unwrap_or_else(|| "agent".to_string())
    }
}

/// Strip YAML frontmatter from markdown content.
///
/// Agent files may have YAML frontmatter (`---\n...\n---`) containing metadata
/// like name and description. This is stripped before merging since the merged
/// file has its own structure.
fn strip_frontmatter(content: &str) -> &str {
    content
        .strip_prefix("---")
        .and_then(|after| after.find("\n---").map(|idx| after[idx + 4..].trim_start()))
        .unwrap_or(content)
}
